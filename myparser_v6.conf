

input {

  file {
    path =>["/root/MCI_ONEDAY_TRACELOG_20251115/my_file/gz_file/*.log"]
    start_position => "beginning"
    sincedb_path => "/dev/null"
    mode => "read"
    file_completed_action => "delete"

  }
}

  filter {


  grok {
    match => {
      "message" =>[
                    "^%{YEAR:year}%{MONTHNUM:month}%{MONTHDAY:day}\s+%{HOUR:hour}%{MINUTE:minute}%{SECOND:second}\.%{INT:msec}\s+%{WORD:log_level} %{WORD:log_type} \[%{DATA:node_name}\] %{GREEDYDATA:log_message}$",
                    "^%{YEAR:year}%{MONTHNUM:month}%{MONTHDAY:day}\s+%{HOUR:hour}%{MINUTE:minute}%{SECOND:second}\.%{INT:msec}\s+%{WORD:log_level} %{GREEDYDATA:log_message}"
      ]
    }
  }

  mutate {
    add_field => {
      "log_timestamp" => "%{year}-%{month}-%{day} %{hour}:%{minute}:%{second}.%{msec}"
    }
  }



   if [log_message] =~ /(?i)Collected/ {
   grok {
      match => { "log_message" => "(?i)(?<collected_flag>Collected)" }
     }
    } else {
     mutate {
       add_field => { "collected_flag" => "NOT_FOUND" }
     }
   }



  
  date {
    match => ["log_timestamp", "yyyy-MM-dd HH:mm:ss.SSS"]
    timezone => "Asia/Tehran"
    target => "log_timestamp"
  }  

   grok {
    match => { "path" => "execution_trace_%{DATA:STREAM_NAME}_%{INT:date}_" }
  }


   if ![STREAM_NAME] {
   mutate {
      add_field => { "STREAM_NAME" => "NOT_FOUND" }
     }
   }
  

  mutate {
    remove_field => [ "year", "month", "day", "hour", "minute", "second", "msec","date"]
  }

}


output {
  elasticsearch {
    hosts => ["https://localhost:9200"]
    index => "elink_parser_v7"
    user => "elastic"
    password => "tHBRq28+RcdaU=YzvQ_i"
    ssl => true
    cacert => "/etc/elasticsearch/certs/http_ca.crt"
  }
}


